# 리플렉션보다는 인터페이스를 사용하라

리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용할 것

### 리플렉션의 단점
- 컴파일 타임 타입 검사가 주는 이점을 하나도 누릴수 없다.
- 리플렉션을 이용하면 코드가 지저분해지고 장황해진다.
- 성능이 떨어진다. (리플렉션을 통한 메서드 호출은 일반적인 방식 보다 속도가 2 ~ 50배 정도 늦어진다.)

리플렉션은 아주 제한적으로만 사용해야 그 단점을 피하고 이점을 취할수 있다.

사실 리플렉션은 컴포넌트 기반 응용 프로그램 저작 도구를 위해 개발 되었기 때문에, 일반적인 프로그램은 프로그램 실행 중에 리플렉션을 통해 객체를 이용하려 하면 안된다.

만약에 써야 되도 리플렉션은 인스턴스 생성에만 사용하고 이렇게 만든 인스턴스는 상위 클래스나 인터페이스를 참조하여 사용하자.

```java
public static void main(String[] args) {
    Class<?> ci = null;
    try {
        ci = Class.forName(args[0]);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    
    Set<String> s = null;
    try {
        s = (Set<String>) ci.newInstance();
    } catch(Exception ex) {
        ex.printStackTrace();
    }
}
```

위의 코드를 보면 Set<String> 객체를 생성할 때 TreeSet 또는 HashSet을 유동적으로 결정하여 만들 수 있다. 그런 부분에서는 굉장한 장점이라고 생각할 수 있다.

하지만

위의 코드의 경우 잘못된 argument값이 들어오게 될 경우 exception이 발생된다. 또한 그냥 객체를 만들면 한줄이면 되는 코드가 되게 길게 늘어지게 되어 가독성이 떨어진다.

장점보다 단점이 많은 리플렉션 기능을 사용을 자제하는 것이 좋다.
만약 컴파일 시점이 아닌 실행시점에 결정이되는 클래스를 만들어야 하는 경우에는, 리플렉션을 사용하되 가능하면 객체를 만들 때만 사요하고, 객체를 참조할 때는 컴파일 시에 알고 있는 인터페이스나 상위 클래스를 이용하는 것이 좋다.(위에서 Set으로 객체를 참조한 것과 같이)